"""
stage11_core400_final.py
------------------------
Final publication-ready visualization of the Vulvodynia Reddit Core Network (Top 400 nodes).

This script:
1. Extracts the 400 most central nodes
2. Detects communities using Louvain modularity
3. Applies a log-scaled Kamada–Kawai layout with random dispersion
4. Highlights key medical terms and top-degree nodes
5. Exports a high-resolution figure suitable for journal publication

Author: Okui & Horie (2025)
Repository: https://github.com/Curiosity-Mars/vulvodynia-stage11-core400-final-visualization
"""

import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
import community as community_louvain
import matplotlib.patheffects as pe
from google.colab import files

# === 1. Extract Top 400 nodes ===
print("=== Extracting Top 400 nodes... ===")
deg_sorted = sorted(deg_centrality.items(), key=lambda x: -x[1])
top400_nodes = [w for w, _ in deg_sorted[:400]]
coreG = G.subgraph(top400_nodes).copy()
print(f"✓ Nodes: {coreG.number_of_nodes()}")
print(f"✓ Edges: {coreG.number_of_edges()}")

# === 2. Louvain community detection ===
partition_core = community_louvain.best_partition(coreG, resolution=1.0)

# === 3. Log-normalized edge weights ===
for u, v, d in coreG.edges(data=True):
    d["w_log"] = np.log1p(d.get("weight", 1))

# === 4. Kamada–Kawai layout with controlled dispersion ===
pos = nx.kamada_kawai_layout(coreG, weight="w_log")
rng = np.random.default_rng(42)
for n in pos:
    pos[n][0] += rng.uniform(-0.3, 0.3)
    pos[n][1] += rng.uniform(-0.3, 0.3)
    pos[n][0] *= 1.8
    pos[n][1] *= 2.0

# === 5. Select important terms for labeling ===
medical_words = [
    "pain", "pelvic", "sex", "floor", "burning", "vulva", "nerve",
    "vaginal", "infection", "skin", "muscles", "vagina", "infections",
    "vulvar", "vaginismus", "painful", "nerves", "itching", "doctor",
    "treatment", "therapy", "symptoms", "diagnosed", "bladder"
]
top30_words = [w for w, _ in deg_sorted[:30] if w in coreG.nodes()]
important_medical = [w for w in medical_words if w in coreG.nodes()]
label_nodes = list(set(top30_words) | set(important_medical))
print(f"✓ Labelled terms: {len(label_nodes)}")

# === 6. Draw network ===
plt.figure(figsize=(20, 16))

nx.draw_networkx_edges(coreG, pos, alpha=0.15, width=0.2, edge_color="gray")

node_colors = [partition_core[n] for n in coreG.nodes()]
node_sizes = [deg_centrality.get(n, 0) * 6000 for n in coreG.nodes()]
nx.draw_networkx_nodes(
    coreG, pos,
    node_color=node_colors,
    cmap=plt.cm.tab20,
    node_size=node_sizes,
    alpha=0.7,
    linewidths=0.5,
    edgecolors="white"
)

# === 7. Highlight important nodes (black border) ===
label_colors = [partition_core[n] for n in label_nodes]
nx.draw_networkx_nodes(
    coreG, pos,
    nodelist=label_nodes,
    node_color=label_colors,
    cmap=plt.cm.tab20,
    node_size=[deg_centrality.get(n, 0) * 9000 for n in label_nodes],
    alpha=1.0,
    linewidths=3.5,
    edgecolors="black"
)

# === 8. Add labels ===
for n in label_nodes:
    if n in pos:
        x, y = pos[n]
        plt.text(
            x, y, n,
            fontsize=11,
            fontweight="bold",
            color="black",
            ha="center",
            va="center",
            path_effects=[pe.withStroke(linewidth=3, foreground="white")]
        )

# === 9. Title and legend info ===
plt.title(
    "Vulvodynia Reddit Core Network (Top 400 Nodes)\n"
    "Colored by Louvain Community | Black border = Key Terms",
    fontsize=18, fontweight="bold"
)
plt.text(
    0.02, 0.02,
    f"Nodes: {len(coreG.nodes())} | Labeled: {len(label_nodes)} | Communities: {len(set(partition_core.values()))}",
    fontsize=11,
    ha="left",
    va="bottom",
    transform=plt.gca().transAxes,
    bbox=dict(boxstyle="round,pad=0.5", facecolor="white", alpha=0.8)
)

plt.axis("off")
plt.tight_layout()

# === 10. Save and download ===
outpath = "/content/drive/MyDrive/Vulvodynia_Core400_Final.png"
plt.savefig(outpath, dpi=300, bbox_inches="tight")
plt.show()
files.download(outpath)

print(f"\n✅ Graph saved: {outpath}")
print(f"✓ Displayed terms: {', '.join(sorted(label_nodes)[:20])}")
